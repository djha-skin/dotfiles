#!/bin/sh
# multipass: print password for given URL and username
# Behavior:
# - For work emails (any email that is NOT one of the two personal addresses below),
#   first try 1Password (op CLI) with a short timeout; on any failure, fall back to KeePassXC.
# - For all others, use existing KeePassXC lookup.
# - Only print the password to stdout on success. Errors and logs go to stderr.

# Debugging control (set MULTIPASS_DEBUG=1 to enable verbose stderr traces)
DEBUG=${MULTIPASS_DEBUG:-0}

# Personal email addresses to EXCLUDE from the 1Password path (case-insensitive)
PERSONAL1="djhaskin987@gmail.com"
PERSONAL2="dan@djhaskin.com"

# Simple stderr logger
log_err() {
    # shellcheck disable=SC2059
    printf "%s\n" "$*" >&2
}

log_dbg() {
    if [ "$DEBUG" -eq 1 ]; then
        printf "DEBUG: %s\n" "$*" >&2
    fi
}

# Keep the existing audit file write (best-effort, does not touch stdout/stderr)
# Note: contains arguments including the username; retained from original script.
# You may remove this if you no longer want local file logging.
{
    # shellcheck disable=SC2128
    echo "$(date) $*" >> "$HOME/.var/log/audit.log"
} || :

url="$1"
username="$2"

if [ -z "${url:-}" ] || [ -z "${username:-}" ]; then
    log_err "usage: multipass <url> <username>"
    exit 2
fi

# Preserve the original vdirsyncer bug workaround
# Fix cases like proto:/path -> proto://path
url=$(printf '%s' "$url" | sed 's|\([^:/]*\):/\([^/]\)|\1://\2|')

lower() {
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

is_email() {
    # Conservative email check: something@something.tld (no spaces)
    printf '%s' "$1" | grep -Eq '^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$'
}

is_personal_email() {
    u_lc=$(lower "$1")
    [ "$u_lc" = "$(lower "$PERSONAL1")" ] || [ "$u_lc" = "$(lower "$PERSONAL2")" ]
}

extract_host() {
    # Extract host from URL, strip port if present
    h=$(printf '%s' "$1" | sed -E 's#^[a-zA-Z][a-zA-Z0-9+.-]*://([^/]+).*#\1#')
    h=${h%%:*}
    printf '%s' "$h"
}

have_cmd() {
    command -v "$1" >/dev/null 2>&1
}

op_available_quick() {
    # Determine the op binary and verify it responds quickly
    OP_BIN=""
    if have_cmd op; then
        OP_BIN="op"
    elif have_cmd 1password; then
        OP_BIN="1password"
    fi
    [ -n "$OP_BIN" ] || return 1

    log_dbg "detected OP_BIN=$OP_BIN"

    # Require timeout to avoid hangs
    if ! have_cmd timeout; then
        # Without timeout, avoid risking hangs
        log_dbg "timeout not found"
        return 1
    fi

    # Quick availability check (won't print anything)
    timeout 2s "$OP_BIN" whoami >/dev/null 2>&1 || {
        log_dbg "op whoami failed or timed out"
        return 1
    }
    log_dbg "op whoami OK"
    return 0
}

op_get_password() {
    # Inputs: URL USERNAME
    u="$1"
    un="$2"

    # Preconditions
    op_available_quick || return 1
    OP_BIN=$(command -v op 2>/dev/null || command -v 1password 2>/dev/null)

    log_dbg "using OP_BIN=$OP_BIN"

    if ! have_cmd jq; then
        # jq is preferred; without it, skip 1Password path for safety
        log_dbg "jq not found; skipping op path"
        return 1
    fi

    host=$(extract_host "$u")
    [ -n "$host" ] || return 1
    log_dbg "extracted host=$host"

    # --- Optimized single list approach ---
    host_lc=$(lower "$host")
    un_lc=$(lower "$un")

    list_json=$(timeout 2s "$OP_BIN" item list --categories Login --format json 2>/dev/null) || list_json=""
    if [ -n "$list_json" ]; then
        has_details=$(printf '%s' "$list_json" | jq 'map(has("fields") or has("urls")) | any' 2>/dev/null || echo "false")
        if [ "$has_details" = "true" ]; then
            log_dbg "item list contains fields/urls; searching in list JSON"
            matched_ids=$(printf '%s' "$list_json" | jq -r --arg u "$un_lc" --arg h "$host_lc" '
                .[] |
                ( .fields? // [] | map(if (.value // "" | type=="string") then (.value|ascii_downcase) else "" end) ) as $usernames |
                ( .urls? // [] | map(.href // "" ) | map(
                    if test("://") then (split("://")[1] // "") else . end
                ) | map(split("/")[0]) | map(split(":")[0]) | map(ascii_downcase) ) as $hosts |
                ( ($usernames | any(. == $u)) and ($hosts | any(. == $h)) ) // false
                | select(.) | .id
            ' 2>/dev/null)
            if [ -n "$matched_ids" ]; then
                count=$(printf '%s
' "$matched_ids" | wc -l)
                log_dbg "matched ids from list: $(printf '%s' "$matched_ids") (count=$count)"
                if [ "$count" -eq 1 ]; then
                    matched_id=$(printf '%s' "$matched_ids" | tr -d '\r\n')
                    log_dbg "single match via list: $matched_id; running single item get"
                    password=$(timeout 2s "$OP_BIN" item get "$matched_id" --format json 2>/dev/null |
                        jq -r '(.fields // []) | map(select(((.purpose // "") == "PASSWORD") or ((.label//""|ascii_downcase)=="password") or ((.id//""|ascii_downcase)=="password"))) | .[].value' 2>/dev/null | head -n1)
                    [ -n "$password" ] || return 1
                    printf '%s\n' "$password"
                    return 0
                fi
                log_dbg "ambiguous matches from list; falling back to per-id check"
            else
                log_dbg "no matches found in list JSON"
            fi
        else
            log_dbg "item list JSON does not include fields/urls; need per-item gets for verification"
        fi
    else
        log_dbg "item list returned empty or timed out"
    fi

    # --- Fallback: previous behaviour but capped ---
    candidates=$(timeout 2s "$OP_BIN" item list --categories Login --format json 2>/dev/null |
        jq -r '.[].id' 2>/dev/null | head -n 50)

    [ -n "$candidates" ] || return 1

    matched_id=""
    for id in $candidates; do
        log_dbg "checking candidate id=$id"
        item_json=$(timeout 2s "$OP_BIN" item get "$id" --format json 2>/dev/null) || { log_dbg "item get failed for $id"; continue; }
        ok=$(printf '%s' "$item_json" | jq -r --arg u "$un_lc" --arg h "$host_lc" '
            def lc($s): ($s // "") | ascii_downcase;
            def hosts:
                (.urls // [])
                | map(.href // "")
                | map( if test("://") then (split("://")[1] // "") else . end )
                | map( split("/")[0] )
                | map( split(":")[0] )
                | map(ascii_downcase)
                ;
            def usernames:
                (.fields // [])
                | map(select((.purpose // "") == "USERNAME" or (lc(.label) == "username") or (lc(.id) == "username")))
                | map(.value // "")
                | map(ascii_downcase)
                ;
            ( (usernames | any(. == $u)) and (hosts | any(. == $h)) ) | tostring
        ' 2>/dev/null)
        log_dbg "candidate $id match_ok=$ok"
        [ "$ok" = "true" ] || continue

        if [ -z "$matched_id" ]; then
            matched_id="$id"
            log_dbg "matched_id set to $matched_id"
        else
            log_dbg "ambiguous matches found (existing $matched_id, new $id); aborting op path"
            matched_id=""
            break
        fi
    done

    [ -n "$matched_id" ] || return 1

    password=$(timeout 2s "$OP_BIN" item get "$matched_id" --format json 2>/dev/null |
        jq -r '(.fields // []) | map(select(((.purpose // "") == "PASSWORD") or ((.label // "" | ascii_downcase) == "password") or ((.id // "" | ascii_downcase) == "password"))) | .[].value' 2>/dev/null | head -n 1)

    [ -n "$password" ] || return 1

    printf '%s\n' "$password"
    return 0
}

get_from_keepass() {
    # Mirror the original KeePassXC credential helper pipeline
    # Only print the password to stdout
    printf 'url=%s\nusername=%s\n' \
        "$url" "$username" | \
        git-credential-keepassxc get 2>/dev/null | \
        awk -F' *= *' '/^password/ {print $2}'
}

username_lc=$(lower "$username")

# Decide path: work email tries 1Password first
if is_email "$username_lc" && ! is_personal_email "$username_lc"; then
    log_dbg "username appears to be work email: $username_lc"
    if pw=$(op_get_password "$url" "$username_lc"); then
        # 1Password success
        printf '%s\n' "$pw"
        exit 0
    fi
    log_dbg "1Password path failed; falling back to KeePassXC"
    # Fall back to KeePassXC
    if pw=$(get_from_keepass) && [ -n "$pw" ]; then
        printf '%s\n' "$pw"
        exit 0
    fi
    log_err "password retrieval failed via 1Password and KeePassXC"
    exit 1
else
    log_dbg "username is personal or not an email; using KeePassXC only"
    # Non-email or personal email: KeePassXC only
    if pw=$(get_from_keepass) && [ -n "$pw" ]; then
        printf '%s\n' "$pw"
        exit 0
    fi
    log_err "password retrieval failed via KeePassXC"
    exit 1
fi
